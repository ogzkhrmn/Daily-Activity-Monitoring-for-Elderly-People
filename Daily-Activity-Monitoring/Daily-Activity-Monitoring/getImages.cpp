//opencv
#define NOMINMAX
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/video/background_segm.hpp>
#include <opencv2\core.hpp>
//C++
#include <sstream>
#include <iostream>
#include <sstream>
#include <OpenNI.h>
#include <opencv2/imgcodecs.hpp>
#include <opencv2/core.hpp>
#include "opencv/cv.hpp"
#include <string>   

using namespace openni;
using namespace cv;
using namespace std;

// Global variables
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor



Mat processVideo(Mat frame) {
	pMOG2->apply(frame, fgMaskMOG2);
	//get the frame number and write it on the current frame
	stringstream ss;
	        rectangle(frame, cv::Point(10, 2), cv::Point(100, 20),
		    cv::Scalar(255, 255, 255), -1);
	string frameNumberString = ss.str();
			putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
			FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 0, 0));
	return  fgMaskMOG2;
}


int ffs()
{
	BOOLEAN first = true;
	Mat before;
	Mat dest, invertcolormatrix;
	Mat addedFrames;
	Mat last,last2;
	VideoWriter output_cap;
	pMOG2 = createBackgroundSubtractorMOG2(1000,50,true); //MOG2 approach
	OpenNI::initialize();
	puts("Kinect initialization...");
	Device device;
	if (device.open(openni::ANY_DEVICE) != 0)
	{
		puts("Kinect not found !");
		return -1;
	}
	puts("Kinect opened");
	VideoStream depth, color;
	color.create(device, SENSOR_COLOR);
	color.start();
	puts("Camera ok");
	depth.create(device, SENSOR_DEPTH);
	depth.start();
	int frameCounter = 1;
	puts("Depth sensor ok");
	VideoMode paramvideo;
	paramvideo.setResolution(640, 480);
	paramvideo.setFps(30);
	paramvideo.setPixelFormat(PIXEL_FORMAT_DEPTH_100_UM);
	depth.setVideoMode(paramvideo);
	paramvideo.setPixelFormat(PIXEL_FORMAT_RGB888);
	color.setVideoMode(paramvideo);
	puts("Reglages des flux videos ok");
	// If the depth/color synchronisation is not necessary, start is faster :
	device.setDepthColorSyncEnabled(false);
	VideoStream** stream = new VideoStream*[2];
	stream[0] = &depth;
	stream[1] = &color;
	puts("Kinect initialization completed");
	if (device.getSensorInfo(SENSOR_DEPTH) != NULL)
	{
		stringstream file;
		VideoFrameRef depthFrame, colorFrame;
		IplImage* colorcv = cvCreateImageHeader(cvSize(640, 480), IPL_DEPTH_8U, 3);
		IplImage* depthcv = cvCreateImageHeader(cvSize(640, 480), IPL_DEPTH_16U, 1);
		//cvNamedWindow("RGB", CV_WINDOW_AUTOSIZE);
		//cvNamedWindow("Depth", CV_WINDOW_AUTOSIZE);
		int changedIndex;
		double alpha = 0.5;
		double beta = 0.5;
		Mat buffer[5], extractedSilhoutte;
		int counter = 0;
		int whichFrame=0;
		while (device.isValid())
		{
			OpenNI::waitForAnyStream(stream, 2, &changedIndex);
			switch (changedIndex)
			{
			case 0:
				depth.readFrame(&depthFrame);
				break;
			case 1:
				color.readFrame(&colorFrame);
				if (colorFrame.isValid())
				{
					colorcv->imageData = (char*)colorFrame.getData();
					cvCvtColor(colorcv, colorcv, CV_BGR2RGB);
					Mat colorcvframe = cvarrToMat(colorcv);
					extractedSilhoutte = processVideo(colorcvframe);
					
					if (frameCounter==6) {
						extractedSilhoutte.copyTo(dest);
					}
					if (frameCounter>6) {
						if (frameCounter%6==0) {
							bitwise_or(dest, extractedSilhoutte, dest);
							imshow("ORIMAGE", dest);
							whichFrame++;
						}
						if (whichFrame == 5) {
							whichFrame = 0;
							bitwise_not(dest, dest);
							imwrite("C:/images/image"+to_string(counter)+".bmp", dest);
							counter++;
							extractedSilhoutte.copyTo(dest);
						}
						
					}
					frameCounter++;
					imshow("DPETH", extractedSilhoutte);
					
				}
				break;
			default:
				puts("Error retrieving a stream");
			}
			cvWaitKey(1);
		}
		cvReleaseImageHeader(&colorcv);
		cvReleaseImageHeader(&depthcv);
		cvDestroyWindow("RGB");
		cvDestroyWindow("Depth");
	}
	depth.stop();
	depth.destroy();
	color.stop();
	color.destroy();
	device.close();
	OpenNI::shutdown();
	return 0;
}